import json
import pygame
from tkinter import *
from random import randint

# Initialiser Pygame pour les sons
pygame.init()
correct_sound = pygame.mixer.Sound('correct.mp3')
wrong_sound = pygame.mixer.Sound('wrong.mp3')

def charger_questions():
    with open('questions.json', 'r', encoding='utf-8') as file:
        return json.load(file)

# Créer une fenêtre grâce à la fonction Tk()
fenetre = Tk()
fenetre.title('Drake The Snake - Trivia Mode')

# Récupérer les dimensions de l'écran
hauteur = fenetre.winfo_screenheight()
largeur = fenetre.winfo_screenwidth()

H = str(int(hauteur / 1.1))
L = str(int(largeur / 2))
fenetre.geometry(L + "x" + H + "+0+0")

# Dimensions du plateau de jeu
LargeurPlateau = largeur / 2
HauteurPlateau = hauteur / 1.2

# Créer un Canvas pour le plateau de jeu
Plateau = Canvas(fenetre, width=LargeurPlateau, height=HauteurPlateau, bg="green")
Plateau.pack(side="bottom")

# Créer un Canvas pour le score
Barre = Text(fenetre, width=int(largeur / 2), height=int(HauteurPlateau / 10), bg="light blue")
Barre.pack(side="top")
Barre.insert(END, "score: 0\n")

# Nombre de cases du plateau
NombreDeCases = 75
LargeurCase = (LargeurPlateau / NombreDeCases)
HauteurCase = (HauteurPlateau / NombreDeCases)

questions = charger_questions()
index_question = 0

def remplir_case(x, y):
    OrigineCaseX1 = x * LargeurCase
    OrigineCaseY1 = y * HauteurCase
    OrigineCaseX2 = OrigineCaseX1 + LargeurCase
    OrigineCaseY2 = OrigineCaseY1 + HauteurCase
    Plateau.create_rectangle(OrigineCaseX1, OrigineCaseY1, OrigineCaseX2, OrigineCaseY2, fill="black")

def case_aleatoire():
    AleatoireX = randint(0, NombreDeCases - 1)
    AleatoireY = randint(0, NombreDeCases - 1)
    return (AleatoireX, AleatoireY)

def dessine_serpent(snake):
    for case in snake:
        x, y = case
        remplir_case(x, y)

def etre_dans_snake(case):
    return 1 if case in SNAKE else 0

def left_key(event):
    global MOUVEMENT
    if MOUVEMENT != (1, 0):  # Empêcher de revenir en arrière
        MOUVEMENT = (-1, 0)

def right_key(event):
    global MOUVEMENT
    if MOUVEMENT != (-1, 0):  # Empêcher de revenir en arrière
        MOUVEMENT = (1, 0)

def up_key(event):
    global MOUVEMENT
    if MOUVEMENT != (0, 1):  # Empêcher de revenir en arrière
        MOUVEMENT = (0, -1)

def down_key(event):
    global MOUVEMENT
    if MOUVEMENT != (0, -1):  # Empêcher de revenir en arrière
        MOUVEMENT = (0, 1)

fenetre.bind("<Left>", left_key)
fenetre.bind("<Right>", right_key)
fenetre.bind("<Up>", up_key)
fenetre.bind("<Down>", down_key)

def serpent_mort(NouvelleTete):
    global PERDU
    NouvelleTeteX, NouvelleTeteY = NouvelleTete
    if (etre_dans_snake(NouvelleTete) and MOUVEMENT != (0, 0)) or NouvelleTeteX < 0 or NouvelleTeteY < 0 or NouvelleTeteX >= NombreDeCases or NouvelleTeteY >= NombreDeCases:
        PERDU = 1

def mise_a_jour_score():
    global SCORE
    SCORE += 1
    Barre.delete(0.0, 3.0)
    Barre.insert(END, "score: " + str(SCORE) + "\n")

def mise_a_jour_snake():
    global SNAKE, SCORE
    (AncienneTeteX, AncienneTeteY) = SNAKE[0]
    MouvementX, MouvementY = MOUVEMENT
    NouvelleTete = (AncienneTeteX + MouvementX, AncienneTeteY + MouvementY)
    serpent_mort(NouvelleTete)
    if not PERDU:
        SNAKE.insert(0, NouvelleTete)
        if SCORE % 2 == 0 and SCORE != 0:  # Ajouter un segment tous les 2 points
            pass
        else:
            SNAKE.pop()

def reinitialiser_jeu():
    global SNAKE, MOUVEMENT, SCORE, PERDU, index_question
    SNAKE = [case_aleatoire()]
    MOUVEMENT = (0, 0)
    SCORE = 0
    PERDU = 0
    index_question = 0

def afficher_question():
    question = questions[index_question]
    options = question["options"]
    Plateau.create_text(LargeurPlateau / 2, HauteurPlateau / 2 - 20, text=question["question"], fill="white")
    positions = [(3, 3), (3, NombreDeCases - 6), (NombreDeCases - 6, 3), (NombreDeCases - 6, NombreDeCases - 6)]
    for i, option in enumerate(options):
        x, y = positions[i]
        Plateau.create_text(x * LargeurCase, y * HauteurCase, text=option, fill="white", anchor="nw")

def verifier_reponse():
    global index_question, PERDU
    question = questions[index_question]
    reponses = {"A": (3, 3), "B": (3, NombreDeCases - 6), "C": (NombreDeCases - 6, 3), "D": (NombreDeCases - 6, NombreDeCases - 6)}
    reponse_choisie = None
    for rep, pos in reponses.items():
        if SNAKE[0] == pos:
            reponse_choisie = rep
            break
    if reponse_choisie == question["answer"]:
        correct_sound.play()
        index_question += 1
        mise_a_jour_score()
        if index_question >= len(questions):
            afficher_felicitations()
            index_question = 0  # Recommence les questions si toutes sont répondues
    else:
        wrong_sound.play()
        PERDU = 1

def afficher_felicitations():
    Plateau.create_text(LargeurPlateau / 2, HauteurPlateau / 2, text="Félicitations ! Vous avez répondu à toutes les questions !", fill="yellow", font=("Helvetica", 24))

def tache():
    if not PERDU:
        fenetre.update()
        fenetre.update_idletasks()
        mise_a_jour_snake()
        verifier_reponse()
        Plateau.delete("all")
        dessine_serpent(SNAKE)
        afficher_question()
        fenetre.after(100, tache)
    else:
        Barre.delete(0.0, 3.0)
        Barre.insert(END, "Perdu avec un score de " + str(SCORE))
        reinitialiser_jeu()
        fenetre.after(2000, tache)

reinitialiser_jeu()  # Assurez-vous de réinitialiser le jeu avant de commencer

fenetre.after(0, tache)
fenetre.mainloop()

# Fermer Pygame quand le programme est terminé
pygame.quit()
